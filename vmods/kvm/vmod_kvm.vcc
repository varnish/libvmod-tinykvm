$Module kvm 3 "High-Performance KVM Sandbox For VCL"

DESCRIPTION
===========

vmod_kvm allows using ultra-low overhead sandboxed programs
directly from VCL, that runs native 64-bit x86 machine code.
Each machine lives in complete separation and does affect any other
programs or the general operation of the cache.
Machines communicate with Varnish using a system call API that covers
all the operational tasks that tenants are allowed to perform.

The VMOD is configured by specifying a list of tenants with
each having a program. Tenants do not need to have an
existing program for Varnish to start. New programs can be
uploaded while Varnish is running and will not affect the
run-time availability or performance of the cache.

Additionally, it is possible to live-debug programs in production.
Each live-debugging session will use a temporary tenant that does
not persist changes in the cache.


TENANT
======

A tenant defines a single program for a group. 

GROUP
======

A group consists of one or more tenants and defines how tenants are executed
within a virtual machine.

- max_time
- max_memory
- max_work_memory
- max_boot_time
- max_concurrency
- hugepages
- allowed_paths (default: []): a list of paths that the tenant can open/load.

API
===

$Function VOID load_tenants(PRIV_VCL, STRING filename)

- Load tenants from file
- See below for example JSON

$Function VOID embed_tenants(PRIV_VCL, STRING json)

- Load tenants directly from embedded JSON.
- Example:
	kvm.embed_tenants("""
		{
			"xpizza.com": {
				"filename": "/tmp/xpizza",
				"key": "key used to verify live updates",
				"group": "test"
			}
		}
	""");

$Function BOOL tenant_is_ready(PRIV_VCL, STRING tenant)

- Returns true if the tenants current program was initialized properly.
- Sending a new program by live update that fails will not replace
  the current program. The only way a program can fail to be ready is
  when the program provided at startup is either missing or failing.

$Function BACKEND live_update(PRIV_VCL, STRING tenant, STRING key, BYTES max_size = 2097152)

- Update this machine using binary data received in a POST
  request. If the machine fails to load, the old machine
  will be kept running.
- The key is used to decide whether the poster is allowed
  to POST programs. It does not have to be used, but it has
  to match the key used for the tenant in the JSON structure.
- Example:
	sub vcl_recv {
		if (req.method == "POST") {
			set req.backend_hint = kvm.live_update(req.http.Host, 15MB);
			std.cache_req_body(15MB);
			return (pass);
		}
	}
	sub vcl_backend_fetch {
		if (bereq.method == "POST") {
			return (fetch);
		}
	}

$Function BOOL live_update_file(PRIV_VCL, STRING tenant, STRING filename)

$Function BACKEND live_debug(PRIV_VCL, STRING tenant, STRING key, BYTES max_size = 2097152)

- Receive a binary suitable for debugging.
- Whenever a request triggers a breakpoint, open a port
  for GDB remote debugging.

$Function INT vm_call(PRIV_VCL, STRING tenant, STRING func, STRING arg = "")

- Looks up tenant, forks a new VM, calls the provided function,
  and then returns the result from the call.
- Subsequent calls on the same task will yield the same VM.
- Use this to make a VCL decision, eg. return (synth ...).

$Function INT vm_callv(PRIV_VCL, STRING tenant,
		ENUM {
			ON_REQUEST
		} func = "ON_REQUEST",
		STRING arg = "")

- Call self-registered function in tenant program.

$Function BACKEND vm_backend(PRIV_VCL, STRING tenant, STRING arg0 = "", STRING arg1 = "")

- Returns a backend that will call into the current machine to produce a response.
- Produces 500 server error if there is not enough memory,
  a limit is hit, or an error is produced.

	set bereq.backend = kvm.vm_backend(bereq.http.Host, bereq.url);

- If the client sends a POST request, it returns a backend that will
  retrieve a POST body first, then call into a KVM program with the body
  and length as arguments. A response must be produced as normal.
- The VMOD will call the POST function in the program, instead of the
  normal GET function.
- If a streaming function is registered, the VMOD will call the streaming
  function in the program for each data segment it receives, and then finally
  it will call the POST function at the end with the whole data segment.
