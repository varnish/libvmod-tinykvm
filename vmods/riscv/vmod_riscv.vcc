$Module riscv 3 "RISC-V Sandbox For VCL"

DESCRIPTION
===========

vmod_riscv allows creating ultra-low overhead virtual machines
per request directly from VCL, that runs 32-bit RISC-V machine code.
Each machine lives in complete separation and cannot affect any other.
Machines communicate with Varnish using a system call API that covers
all the basic tasks that tenants want to perform.
Any programming language that is able to produce RISC-V machine code can
be used on top of this, which allows using modern programming concepts,
with complete language runtime-environments.

Due to the low overhead nature of the machines, the API may be somewhat
unique, however it's intended to be used by CDNs who know what they are doing.

Example:
	sub vcl_init {
		/* These functions will be callable on every machine */
		riscv.add_known_function("on_client_request");
		riscv.add_known_function("on_synth");

		/* Create some machines */
		new ypizza = riscv.machine(
			name = "ypizza.com",
			group = "premium",
			filename = "/path/to/binary");
		/* This specific machine has more functions we can call */
		ypizza.add_known_function("test");
	}

	sub vcl_recv {
		/* We can call functions directly by name */
		ypizza.call("on_client_request");
		/* But also by order of add_known_function */
		ypizza.call_index(0);

		/* We can query what the machine wants to happen */
		if (riscv.want_result() == "synth") {
			/* And then do it for them */
			return (synth(riscv.want_status()));
		}

		/* If we don't like it, we can do our own thing */
		return (synth(403, "Verboten"));
	}


API
===

$Object machine(STRING name, STRING filename, STRING group = "", INT max_instructions = 2000000)

- Create named machine that is initialized immediately
- Broken machines return 500 server error

$Method VOID    .add_known_function(STRING function)

- Make this function faster to call later on.

$Method INT     .call(STRING function)

- Call into a new virtual machine quickly forked from the previously
  prepared machine, using copy-on-write mechanics.

$Method INT     .call_index(INT index)

- Call into a new virtual machine quickly forked from the previously
  created machine, using copy-on-write mechanics. The index is the
  entry number (counting from zero) given to add_known_function.

  Example:

  riscv.add_known_function("on_client_request")
  riscv.add_known_function("on_synth")
  new ypizza = riscv.machine(
	  name = "ypizza.com",
	  filename = "/home/gonzo/github/rvscript/programs/test");

  ypizza.call_index(0); /* Call on_client_request */

$Method BACKEND .live_update(BYTES max_size = 2097152)

- Update this machine using binary data received in the
  current request. If the machine fails to load, the old machine
  will be kept running.


$Function VOID    add_known_function(STRING function)

- Adds the given function to a list of functions that will be
  automatically pre-warmed on each new machine created. The
  function does not have to exist on every machine.

$Function BOOL    machine_present()

- Returns true if there is a currently active machine.

$Function INT     call(STRING function)

- Calls the given function in the currently active machine.

$Function INT     call_index(INT index)

- Calls the given function at index in order added by add_known_function
  (starting at zero), in the currently active machine.

$Function STRING  current_name()

- Returns the name of the currently active machine.
- If no machine has been running in the current stage of VCL,
  this function will return null, which can be tested in if statements.

$Function STRING  current_group()

- Returns the group of the currently active machine.
- If no machine has been running in the current stage of VCL,
  this function will return null, which can be tested in if statements.

$Function STRING  want_result()

- Returns the VCL decision that the guest wants to happen:
  Lookup, Synth, etc.

$Function INT     want_status()

- Returns the status code that the guest wants to use, if relevant.


SIMPLE EXECUTION
================

These functions allows for simple execution of RISC-V machine code.
The backend variant will take body bytes and try to execute it, then return
the output from the machine in the response. Both functions set quite a few
headers which all give information on how the execution went.

$Function STRING exec(HTTP req, INT max_instructions, BLOB elf)

Execute the given ELF binary, running its main function to completion or runs out of instructions limited by max_instructions. This will also initialize the machine, and may call destructors before exiting.

- All measurements are stored in several HTTP header fields
- Errors are stored in a X-Exception header field.
- If an error occurs the return value is null (empty).
- On success the machine output is returned.

$Object backend(INT max_instructions = 2000000, STRANDS arguments = 0)

$Method BACKEND .from_body()
