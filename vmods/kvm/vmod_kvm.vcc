$Module kvm 3 "High-Performance KVM Sandbox For VCL"

DESCRIPTION
===========

vmod_kvm allows using ultra-low overhead virtual machines
directly from VCL, that runs native x86 machine code.
Each machine lives in complete separation and cannot affect any other.
Machines communicate with Varnish using a system call API that covers
all the basic tasks that tenants want to perform.

The VMOD is configured by specifying a list of tenants with
each having a program path. Tenants do not need to have an
existing program for Varnish to start. New programs can be
uploaded while Varnish is running and will not affect the
run-time performance of the cache.

Additionally, it is possible to live-debug programs in production.
Each live-debugging session will use a temporary tenant that does
not persist changes in the cache.


API
===

$Function VOID load_tenants(PRIV_VCL, STRING filename)

- Load tenants from file
- See below for example JSON

$Function VOID embed_tenants(PRIV_VCL, STRING json)

- Load tenants directly from embedded JSON.
- Example:
	kvm.embed_tenants("""
		{
			"xpizza.com": {
				"filename": "/tmp/xpizza",
				"key": "key used to verify live updates",
				"group": "test"
			}
		}
	""");

$Function BOOL tenant_is_ready(PRIV_VCL, STRING tenant)

- Returns true if the tenants current program was initialized properly.
- Sending a new program by live update that fails will not replace
  the current program. The only way a program can fail to be ready is
  when the program provided at startup is either missing or failing.

$Function VOID cache_symbol(STRING symbol)

- Looks up the given symbol in all programs initialized
  after calling this function, and then caches it.
- Cached symbols are much faster to call.

$Function BACKEND live_update(PRIV_VCL, STRING tenant, STRING key, BYTES max_size = 2097152)

- Update this machine using binary data received in a POST
  request. If the machine fails to load, the old machine
  will be kept running.
- The key is used to decide whether the poster is allowed
  to POST programs. It does not have to be used, but it has
  to match the key used for the tenant in the JSON structure.
- Example:
	sub vcl_recv {
		if (req.method == "POST") {
			set req.backend_hint = kvm.live_update(req.http.Host, 15MB);
			std.cache_req_body(15MB);
			return (pass);
		}
	}
	sub vcl_backend_fetch {
		if (bereq.method == "POST") {
			return (fetch);
		}
	}

$Function BACKEND live_debug(PRIV_VCL, STRING tenant, STRING key, BYTES max_size = 2097152)

- Receive a binary suitable for debugging.
- Whenever a request triggers a breakpoint, open a port
  for GDB remote debugging.

$Function INT vm_call(PRIV_VCL, STRING tenant, STRING func, STRING arg = "")

- Looks up tenant, forks a new VM, calls the give function,
  and then returns the result from the call.
- Subsequent calls on the same task will yield the same VM.
- Use this to make a VCL decision, eg. return (synth ...).

$Function INT vm_synth()

- Produces a synthetic response using the current active machine.
- Can only be called from vcl_synth or vcl_backend_error.

$Function BACKEND vm_backend(PRIV_VCL, STRING tenant, STRING func, STRING arg = "")

- Returns a backend that will call into the current machine to produce a response.
- Produces 500 server error if there is not enough memory,
  a limit is hit, or an error is produced.

	set bereq.backend = kvm.vm_backend("xpizza.com", "my_backend");

$Function BACKEND vm_post_backend(PRIV_VCL,
	STRING tenant, STRING func, STRING arg = "", STRING processing = "")

- Returns a backend that will retrieve a POST body first,
  then call into a KVM VM with the body as argument, and then produce a response.
- Produces 500 server error if there is not enough memory,
  a limit is hit, or an error is produced.
- When the processing function is provided, the backend will be streaming
  the request body data into the VM by calling the processing function on
  each data segment. The processing function will need to return the
  length processed to confirm that it was handled.
  When the last streamed segment has been received, the processing Function
  will have the 'last' argument set to 1. Finally, the regular POST function
  will be called with the data argument removed, and the final length passed.
  In the final call a backend response must be provided. Streaming is more
  memory efficient and makes processing possible on big data, but it requires
  the data processor to be able to work with segmented data.

	set bereq.backend = kvm.vm_post_backend("xpizza.com", "my_post_backend");

  Regular POST function prototype:
    extern void __attribute__((used))
    my_post_backend(const char *arg, void *data, size_t len)


  Prototypes for streaming:
  - Processing function:
    extern long __attribute__((used))
    my_streaming_function(void *data, size_t len, size_t processed, int last)
  - Final function:
    extern void __attribute__((used))
    my_streaming_response(const char *arg, size_t len)
