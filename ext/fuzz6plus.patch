diff --git a/bin/varnishd/hpack/vhp_gen_hufdec.c b/bin/varnishd/hpack/vhp_gen_hufdec.c
index 5f864402a..da0593a94 100644
--- a/bin/varnishd/hpack/vhp_gen_hufdec.c
+++ b/bin/varnishd/hpack/vhp_gen_hufdec.c
@@ -92,6 +92,16 @@ tbl_new(unsigned mask)
 	return (tbl);
 }
 
+static void
+tbl_free(struct tbl* table)
+{
+	for (unsigned i = 0; i < table->n; i++) {
+		if (table->e[i].next != NULL)
+			tbl_free(table->e[i].next);
+	}
+	free(table);
+}
+
 static void
 tbl_add(struct tbl *tbl, uint32_t code, unsigned codelen,
     uint32_t bits, unsigned len, char chr)
@@ -250,5 +260,6 @@ main(int argc, const char **argv)
 	tbl_print(top);
 	printf("};\n");
 
+	tbl_free(top);
 	return (0);
 }
diff --git a/bin/varnishd/mgt/mgt_child.c b/bin/varnishd/mgt/mgt_child.c
index 919fd6cc1..5fa2ec98f 100644
--- a/bin/varnishd/mgt/mgt_child.c
+++ b/bin/varnishd/mgt/mgt_child.c
@@ -289,6 +289,71 @@ child_poker(const struct vev *e, int what)
  * Launch the child process
  */
 
+static void child_startup(void* userdata)
+{
+	unsigned u;
+	char *p;
+	struct vev *e;
+	int i, cp[2];
+
+	/* Redirect stdin/out/err */
+#ifndef SINGLE_PROCESS_MODE
+	VFIL_null_fd(STDIN_FILENO);
+	assert(dup2(heritage.std_fd, STDOUT_FILENO) == STDOUT_FILENO);
+	assert(dup2(heritage.std_fd, STDERR_FILENO) == STDERR_FILENO);
+#endif
+	/*
+	 * Close all FDs the child shouldn't know about
+	 *
+	 * We cannot just close these filedescriptors, some random
+	 * library routine might miss it later on and wantonly close
+	 * a FD we use at that point in time. (See bug #1841).
+	 * We close the FD and replace it with /dev/null instead,
+	 * That prevents security leakage, and gives the library
+	 * code a valid FD to close when it discovers the changed
+	 * circumstances.
+	 */
+#ifndef SINGLE_PROCESS_MODE
+	closelog();
+	for (i = STDERR_FILENO + 1; i <= CLOSE_FD_UP_TO; i++) {
+		if (vbit_test(fd_map, i))
+			continue;
+		if (close(i) == 0)
+			VFIL_null_fd(i);
+	}
+	for (i = CLOSE_FD_UP_TO + 1; i <= CHECK_FD_UP_TO; i++) {
+		assert(close(i) == -1);
+		assert(errno == EBADF);
+	}
+#endif
+	mgt_ProcTitle("Child");
+
+	heritage.cls = mgt_cls;
+	heritage.ident = VSB_data(vident) + 1;
+
+	VJ_subproc(JAIL_SUBPROC_WORKER);
+
+	heritage.proc_vsmw = VSMW_New(heritage.vsm_fd, 0640, "_.index");
+	AN(heritage.proc_vsmw);
+
+	/*
+	 * We pass these two params because child_main needs them
+	 * Well before it has found its own param struct.
+	 */
+	child_main(mgt_param.sigsegv_handler,
+		mgt_param.wthread_stacksize);
+
+	/*
+	 * It would be natural to clean VSMW up here, but it is apt
+	 * to fail in some scenarios because of the fall-back
+	 * "rm -rf" in mgt_SHM_ChildDestroy() which is there to
+	 * catch the cases were we don't get here.
+	 */
+	// VSMW_Destroy(&heritage.proc_vsmw);
+
+	exit(0);
+}
+
 static void
 mgt_launch_child(struct cli *cli)
 {
@@ -329,72 +394,23 @@ mgt_launch_child(struct cli *cli)
 
 	AN(heritage.param);
 	AN(heritage.panic_str);
+#ifndef SINGLE_PROCESS_MODE
 	if ((pid = fork()) < 0) {
 		perror("Could not fork child");
 		exit(1);		// XXX Harsh ?
 	}
 	if (pid == 0) {
-
-		/* Redirect stdin/out/err */
-		VFIL_null_fd(STDIN_FILENO);
-		assert(dup2(heritage.std_fd, STDOUT_FILENO) == STDOUT_FILENO);
-		assert(dup2(heritage.std_fd, STDERR_FILENO) == STDERR_FILENO);
-
-		/*
-		 * Close all FDs the child shouldn't know about
-		 *
-		 * We cannot just close these filedescriptors, some random
-		 * library routine might miss it later on and wantonly close
-		 * a FD we use at that point in time. (See bug #1841).
-		 * We close the FD and replace it with /dev/null instead,
-		 * That prevents security leakage, and gives the library
-		 * code a valid FD to close when it discovers the changed
-		 * circumstances.
-		 */
-		closelog();
-
-		for (i = STDERR_FILENO + 1; i <= CLOSE_FD_UP_TO; i++) {
-			if (vbit_test(fd_map, i))
-				continue;
-			if (close(i) == 0)
-				VFIL_null_fd(i);
-		}
-		for (i = CLOSE_FD_UP_TO + 1; i <= CHECK_FD_UP_TO; i++) {
-			assert(close(i) == -1);
-			assert(errno == EBADF);
-		}
-
-		mgt_ProcTitle("Child");
-
-		heritage.cls = mgt_cls;
-		heritage.ident = VSB_data(vident) + 1;
-
-		VJ_subproc(JAIL_SUBPROC_WORKER);
-
-		heritage.proc_vsmw = VSMW_New(heritage.vsm_fd, 0640, "_.index");
-		AN(heritage.proc_vsmw);
-
-		/*
-		 * We pass these two params because child_main needs them
-		 * Well before it has found its own param struct.
-		 */
-		child_main(mgt_param.sigsegv_handler,
-		    mgt_param.wthread_stacksize);
-
-		/*
-		 * It would be natural to clean VSMW up here, but it is apt
-		 * to fail in some scenarios because of the fall-back
-		 * "rm -rf" in mgt_SHM_ChildDestroy() which is there to
-		 * catch the cases were we don't get here.
-		 */
-		// VSMW_Destroy(&heritage.proc_vsmw);
-
-		exit(0);
+		child_startup(NULL);
 	}
 	assert(pid > 1);
+#else
+	pthread_create(&pid, NULL, child_startup, NULL);
+#endif
+
 	MGT_Complain(C_DEBUG, "Child (%jd) Started", (intmax_t)pid);
 	VSC_C_mgt->child_start++;
 
+#ifndef SINGLE_PROCESS_MODE
 	/* Close stuff the child got */
 	closefd(&heritage.std_fd);
 
@@ -403,6 +419,7 @@ mgt_launch_child(struct cli *cli)
 
 	MCH_Fd_Inherit(heritage.cli_out, NULL);
 	closefd(&heritage.cli_out);
+#endif
 
 	child_std_vlu = VLU_New(child_line, NULL, 0);
 	AN(child_std_vlu);
@@ -451,7 +468,6 @@ mgt_launch_child(struct cli *cli)
 	free(p);
 	child_state = CH_RUNNING;
 }
-
 /*=====================================================================
  * Cleanup when child dies.
  */
diff --git a/bin/varnishd/mgt/mgt_main.c b/bin/varnishd/mgt/mgt_main.c
index 47e6084c7..f565c29df 100644
--- a/bin/varnishd/mgt/mgt_main.c
+++ b/bin/varnishd/mgt/mgt_main.c
@@ -430,8 +430,12 @@ mgt_f_read(const char *fn)
 	VTAILQ_INSERT_TAIL(&f_args, fa, list);
 }
 
+#ifndef LIBFUZZER_ENABLED
 int
 main(int argc, char * const *argv)
+#else
+int varnishd_main(int argc, char * const *argv)
+#endif
 {
 	int o, eric_fd = -1;
 	unsigned C_flag = 0;
@@ -901,6 +905,9 @@ main(int argc, char * const *argv)
 		u = MCH_Start_Child();
 	else
 		u = 0;
+#ifdef LIBFUZZER_ENABLED
+	return u;
+#endif
 
 	if (eric_fd >= 0)
 		mgt_eric_im_done(eric_fd, u);
diff --git a/bin/varnishd/mgt/mgt_vcc.c b/bin/varnishd/mgt/mgt_vcc.c
index c42e889d7..7e29f2fbb 100644
--- a/bin/varnishd/mgt/mgt_vcc.c
+++ b/bin/varnishd/mgt/mgt_vcc.c
@@ -130,7 +130,11 @@ run_vcc(void *priv)
 	}
 	closefd(&fd);
 	VSB_destroy(&csrc);
+#ifndef LIBFUZZER_ENABLED
 	exit(0);
+#else
+	_exit(0);
+#endif
 }
 
 /*--------------------------------------------------------------------
@@ -198,7 +202,11 @@ run_dlopen(void *priv)
 	CAST_OBJ_NOTNULL(vp, priv, VCC_PRIV_MAGIC);
 	if (VCL_TestLoad(vp->libfile))
 		exit(1);
+#ifndef LIBFUZZER_ENABLED
 	exit(0);
+#else
+	_exit(0);
+#endif
 }
 
 /*--------------------------------------------------------------------
