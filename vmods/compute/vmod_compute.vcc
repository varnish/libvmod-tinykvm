$Module compute 3 "High-Performance Compute For Varnish Enterprise"

DESCRIPTION
===========

vmod_compute uses sandboxed native programs in order to read and
transform data without having to worry about security and integrity
issues. Programs are loaded on-demand and can also be individually
configured to meet the specific needs of each Varnish Cache server.

A library defines a group of ready-to-use native programs. Varnish Enterprise
has a list of officially supported programs, each of which solve a specific task.
A library will only contain definitions of programs, and they do not consume
any resources until a program is needed by a request. When a program is needed,
it is fetched, loaded and then it will process requests until shutdown. This
means that the first request to any program will wait for it to load.

Programs provided by a library are ready-to-use, and will often have one
single purpose. Programs are documented on the Varnish Software docs website
and comes with a simple explanation of what it does, and what configuration
should be provided to make the program perform a given function.

See http://compute.varnish-software.com for a list of official programs.

Example:
	sub vcl_init {
		new compvs = activedns.dns_group();
		compvs.set_host("compute.varnish-software.com");

		compute.library("https://.../compute.json");
	}

	sub vcl_backend_fetch {
		set bereq.backend = compute.backend("myprogram",
			"https://${compvs}/images/" + bereq.url);
	}

	This will employ 'myprogram' as a backend. DNS configuration can be
	handled using ActiveDNS, and uses the ${name} string-interpolation method.


The primary way to increase or decrease the resource consumption of a program
is to control the concurrency level. If a program is not handling requests fast
enough, increase the number of VMs for that program. If the Varnish Cache is
using too much CPU, try reducing the concurrency level.

Example:
	sub vcl_init {
		compute.library("https://.../compute.json");
		compute.configure("myprogram", """{
			"concurrency": 32
		}""");
	}

Most programs should have a healthy amount of maximum memory available to them in
order to complete their tasks. You can tweak this manually using the same configure
function as needed.

You can find each individual setting at http://compute.varnish-software.com.

API
===

$Event vmod_event

$Function BOOL library(PRIV_VCL, STRING uri)

- Fetch library of programs that is pre-installed with Varnish Enterprise.
- Libraries contain program definitions, but programs are only started on-demand.
- Must be called from vcl_init.

$Function BOOL init_self_requests(PRIV_VCL, STRING unix_socket,
	STRING http_prefix = "http://127.0.0.1:6081",
	INT max_concurrent_requests = 50)

- Used by all self-requests.
- Set the location where Varnish (or another server) can be found.
- If unix_path is specified, it must be a Unix Domain Socket path accessible by Varnish.
- If unix_path is not specified, the http_prefix must be accessible by Varnish.
- The max concurrent self-requests parameter is a last resort to avoid loops.
- Must be called from vcl_init.

$Function BOOL add_program(PRIV_VCL, STRING name, STRING uri)

- Name is used to be able to refer to the program later, using configure, etc.
- URI can be a local filename, eg. "file:///tmp/my_program".
- Program is added to the default group. Use configure() to override.
- Must be called from vcl_init.

$Function BOOL invalidate_program(PRIV_VCL, STRING program)

- Unloads a program.
- The next request to it will cause the program to be reloaded.
- If program is "*" then all programs are unloaded.

$Function BOOL configure(PRIV_VCL, STRING program, STRING json)

- Provide a JSON configuration to override defaults to unstarted programs.
- The JSON configuration is the same as when configuring a program normally,
  but there are no mandatory fields.
- Must be called from vcl_init.

$Function BOOL start(PRIV_VCL, STRING program, BOOL async = 1)

- Start program during early Varnish startup.
- When async, program intialization will not delay Varnish from starting up.
  Requests will wait until the program is fully initialized.
- Must be called from vcl_init.

$Function BOOL chain(PRIV_VCL, STRING program, STRING arg = "", STRING config = "")

- Queue this program up for execution in the exact order given.
- Returns true if the program was found.
- A program chain always end with a call to program().
- Must be called from vcl_backend_fetch.

$Function BACKEND program(PRIV_VCL, STRING program, STRING arg = "", STRING config = "")

- Returns a backend that will call the given program to produce a response.
- Execute each program in the chain, and *then* run this program to produce a final response.
- Supports GET, POST and other HTTP requests, as well as streaming modes.
- All computation happens in between vcl_backend_fetch and vcl_backend_response.
- Must be called from vcl_backend_fetch.

$Function STRING to_string(PRIV_VCL, STRING program, STRING arg = "", STRING config = "", STRING on_error = "")

- Returns a string of the response produced by the given program.
- Supports GET, POST and other HTTP requests.
- If the program fails, this function returns the on_error string instead.
- Works with chaining, and calls to_string() for the final string after chained programs.
- NOTE: Uses extra workspace for each call. See: man varnishd, workspace_backend.


$Function BOOL steal(PRIV_VCL, STRING program, STRING arg = "")

- Takes over the current clients TCP connection and passes it to the given program.
- The request fails if the HTTP version is 2.x or 3.x. Only 1.x is supported.
- The program must have socket callbacks. The entries are specified in the API docs.
- The program has access to the underlying file descriptor (virtualized).
- The on_connect callback receives the client IP and the provided argument.
- Returns true if detaching the clients fd succeeded, including on_connect.
- Must be called from vcl_recv.
