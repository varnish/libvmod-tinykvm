$Module riscv 3 "RISC-V Sandbox For VCL"

DESCRIPTION
===========

vmod_riscv allows creating ultra-low overhead virtual machines
per request directly from VCL, that runs RISC-V machine code.
Each machine lives in complete separation and cannot affect any other.
Machines communicate with Varnish using a system call API that covers
all the basic tasks that tenants want to perform.
Any programming language that is able to produce RISC-V machine code can
be used on top of this, which allows using modern programming concepts,
and complete runtime-environments.

Due to the low overhead nature of the machines, the API may be somewhat
unique, however it's intended to be used by CDNs who know what they are doing.

Example:
	sub vcl_init {
		/* Initialize some tenants from JSON */
		riscv.load_tenants("/path/to/tenants.json");
	}

	sub vcl_recv {
		/* Select a tenant to handle this request */
		riscv.fork("ypizza.com");
		/* Add CDNs custom header fields */
		set req.http.X-Tenant = riscv.current_name();
		/* We can call functions directly by name */
		riscv.call("on_client_request");

		/* We can query what the machine wants to happen */
		if (riscv.want_result() == "synth") {
			/* And then do it for them */
			return (synth(riscv.want_status()));
		}

		/* If we don't like it, we can do our own thing */
		return (synth(403, "Verboten"));
	}


API
===

$Function VOID load_tenants(STRING json_filepath)

- Load tenants from a JSON file in this format:

	"group_name": {
		"max_instructions": 2000000,
		"max_memory": 4194304,
		"max_heap":  4194304
	},
	"tenant_name": {
		"filename": "/path/to/program",
		"group": "groupname"
	}

- The program does not have to exist, it only needs to be
  accessible to Varnish. When a tenant sends a new program
  to Varnish, it will try to write to that location.

$Function BOOL    fork(STRING tenant)

- Tenant names are the object names in the JSON configuration file.
- Quickly create a new tenant machine forked from a previously
  fully prepared machine, using copy-on-write mechanics.
- Returns true if the fork succeeded.

$Function BACKEND live_update(STRING tenant, BYTES max_size = 2097152)

- Update this machine using binary data received in the
  current request. If the machine fails to load, the old machine
  will be kept running.
- Tenant name must be specified to avoid accidents.


$Function BOOL    active()

- Returns true if there is a currently active tenant.

$Function INT     call(STRING function)

- Calls the given function in the currently active machine.

$Function INT     fastcall(ENUM {ON_REQUEST, ON_HASH, ON_SYNTH,
		ON_BACKEND_FETCH, ON_BACKEND_RESPONSE} index = "ON_REQUEST")

- Calls the given function at index in order added by add_known_function
  (starting at zero), in the currently active machine.

$Function INT     resume()

- Resumes a paused tenant machine.

$Function STRING  current_name()

- Returns the name of the currently active machine.
- If no machine has been running in the current stage of VCL,
  this function will return null, which can be tested in if statements.

$Function STRING  current_group()

- Returns the group of the currently active machine.
- If no machine has been running in the current stage of VCL,
  this function will return null, which can be tested in if statements.

$Function STRING  want_result()

- Returns the VCL decision that the guest wants to happen:
  Lookup, Synth, etc.

$Function INT     want_status()

- Returns the status code that the guest wants to use, if relevant.
- Returns zero (0) if no status has been set.

$Function BOOL    want_resume()

- Returns true if the machine was paused, and may be resumed.

$Function BACKEND vm_backend(STRING func = 0)

- Returns a backend that will call into the current machine to produce a response.
- Produces 500 server error if there is no active machine, or an error happens.
- Call with no function specified if tenant has made a "backend" decision.

	if (riscv.want_result() == "backend") {
		set req.backend_hint = riscv.vm_backend();
		return (hash);
	}


SIMPLE EXECUTION
================

These functions allows for simple execution of RISC-V machine code.
The backend variant will take body bytes and try to execute it, then return
the output from the machine in the response. Both functions set quite a few
headers which all give information on how the execution went.

$Function STRING exec(HTTP req, INT max_instructions, BLOB elf)

Execute the given ELF binary, running its main function to completion or runs out of instructions limited by max_instructions. This will also initialize the machine, and may call destructors before exiting.

- All measurements are stored in several HTTP header fields
- Errors are stored in a X-Exception header field.
- If an error occurs the return value is null (empty).
- On success the machine output is returned.

$Object backend(INT max_instructions = 2000000, STRANDS arguments = 0)

$Method BACKEND .from_body()
