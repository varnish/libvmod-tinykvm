$Module riscv 3 "RISC-V Sandbox For VCL"

DESCRIPTION
===========

vmod_riscv allows creating ultra-low overhead virtual machines
per request directly from VCL, that runs 32-bit RISC-V machine code.
Each machine lives in complete separation and cannot affect any other.
Machines communicate with Varnish using a system call API that covers
all the basic tasks that tenants want to perform.
Any programming language that is able to produce RISC-V machine code can
be used on top of this, which allows using modern programming concepts,
with complete language runtime-environments.

Due to the low overhead nature of the machines, the API may be somewhat
unique, however it's intended to be used by CDNs who know what they are doing.

Example:
	sub vcl_init {
		/* Create some machines */
		new ypizza = riscv.machine(
			name = "ypizza.com",
			group = "premium",
			filename = "/tmp/tenants/ypizza");
		/* This specific machine has more functions we can call */
		ypizza.add_known_function("test");
	}

	sub vcl_recv {
		/* We can call functions directly by name */
		ypizza.call("on_client_request");

		/* We can query what the machine wants to happen */
		if (riscv.want_result() == "synth") {
			/* And then do it for them */
			return (synth(riscv.want_status()));
		}

		/* If we don't like it, we can do our own thing */
		return (synth(403, "Verboten"));
	}


API
===

$Function VOID add_known_function(STRING function)

- Adds the given function to a list of functions that will be
  automatically pre-warmed on each new machine created. The
  function does not have to exist on every machine.


$Object machine(STRING name, STRING filename, STRING group = "", INT max_instructions = 2000000, INT max_memory = 8388608)

- Create named machine that is initialized immediately
- Broken machines return 500 server error

$Method VOID    .add_known_function(STRING function)

- Make this function faster to call later on.

$Method INT     .fork()

- Create a new virtual machine quickly forked from the previously
  prepared machine, using copy-on-write mechanics.
  "on_init",
  "on_client_request",
  "on_hash",
  "on_synth",
  "on_backend_fetch",
  "on_backend_response"

$Method INT     .call(STRING function)

$Method INT     .fastcall(ENUM {ON_REQUEST, ON_HASH, ON_SYNTH,
		ON_BACKEND_FETCH, ON_BACKEND_RESPONSE} index = "ON_REQUEST")

- Call given function in this virtual machine.
- If no machine is forked, fork.

  Example:

  new ypizza = riscv.machine(
	  name = "ypizza.com",
	  filename = "/tmp/test");

  ypizza.call("on_client_request");
  ypizza.fastcall(ON_REQUEST);

$Method BACKEND .live_update(BYTES max_size = 2097152)

- Update this machine using binary data received in the
  current request. If the machine fails to load, the old machine
  will be kept running.

$Method BACKEND .vm_backend(STRING function)

- Call given function and use as generator for backend response


$Function BOOL    machine_present()

- Returns true if there is a currently active machine.

$Function INT     call(STRING function)

- Calls the given function in the currently active machine.

$Function INT     fastcall(ENUM {ON_REQUEST, ON_HASH, ON_SYNTH,
		ON_BACKEND_FETCH, ON_BACKEND_RESPONSE} index = "ON_REQUEST")

- Calls the given function at index in order added by add_known_function
  (starting at zero), in the currently active machine.

$Function STRING  current_name()

- Returns the name of the currently active machine.
- If no machine has been running in the current stage of VCL,
  this function will return null, which can be tested in if statements.

$Function STRING  current_group()

- Returns the group of the currently active machine.
- If no machine has been running in the current stage of VCL,
  this function will return null, which can be tested in if statements.

$Function STRING  want_result()

- Returns the VCL decision that the guest wants to happen:
  Lookup, Synth, etc.

$Function INT     want_status()

- Returns the status code that the guest wants to use, if relevant.

$Function BACKEND vm_backend()

- Returns a backend that will call into the current machine to produce a response.
- Produces 500 server error if there is no active machine, or an error happens.


SIMPLE EXECUTION
================

These functions allows for simple execution of RISC-V machine code.
The backend variant will take body bytes and try to execute it, then return
the output from the machine in the response. Both functions set quite a few
headers which all give information on how the execution went.

$Function STRING exec(HTTP req, INT max_instructions, BLOB elf)

Execute the given ELF binary, running its main function to completion or runs out of instructions limited by max_instructions. This will also initialize the machine, and may call destructors before exiting.

- All measurements are stored in several HTTP header fields
- Errors are stored in a X-Exception header field.
- If an error occurs the return value is null (empty).
- On success the machine output is returned.

$Object backend(INT max_instructions = 2000000, STRANDS arguments = 0)

$Method BACKEND .from_body()
